---
title: "Service Patterns"
author: "Flavio Poletti"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tidytransit-Service Patterns}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r setup, include=FALSE}
library(knitr)
library(tidytransit)
library(dplyr)
library(lubridate)
library(openssl)
library(ggplot2)
knitr::opts_chunk$set(echo = TRUE)
```
  
## Overview

Each trip in a GTFS feed is referenced to a service_id (in trips.txt). The [GTFS reference](https://developers.google.com/transit/gtfs/reference/#calendartxt) 
specifies that a "service_id contains an ID that uniquely identifies a set of dates when 
service is available for one or more routes". A service could run on every weekday or only 
on saturdays for example. Other possible services run only on holidays during a year, 
independent of weekdays. However, feeds are not required to indicate anything with 
service_ids and some feeds even use a unique `service_id` for each trip and day. In 
this vignette we'll look at a general way to gather information on when trips run by 
using "service patterns".
  
## Prepare data

We use a feed from the New York Metropolitan Transportation Authority. It is provided 
as a sample feed with tidytransit but you can read it directly from the MTA's website. 
  
```{r}
local_gtfs_path <- system.file("extdata", "google_transit_nyc_subway.zip", package = "tidytransit")
gtfs <- read_gtfs(local_gtfs_path, local=TRUE)
# gtfs <- read_gtfs("http://web.mta.info/developers/data/nyct/subway/google_transit.zip")
```
  
With `get_date_service_table()` we receive a table that indicates which service_id runs 
on which date. This is later useful for linking dates and trips via service_id. 

```{r}
gtfs$date_service_table <- get_date_service_table(gtfs)

print(gtfs$date_service_table)
```

To understand service patterns better we need information on weekdays and holidays. With 
a calendar table we know the weekday and possible holidays for each date. We'll use a minimal example 
with two holidays.

```{r}
holidays = tribble(~date, ~holiday,
  ymd("2018-07-04"), "Independence Day",
  ymd("2018-09-03"), "Labor Day")

calendar = tibble(date = unique(gtfs$date_service_table$date)) %>% 
  mutate(
    weekday = (function(date) {
      c("Sunday", "Monday", "Tuesday", 
        "Wednesday", "Thursday", "Friday", 
        "Saturday")[as.POSIXlt(date)$wday + 1]
    })(date)
  )

calendar <- calendar %>% left_join(holidays, by = "date")

print(calendar)
```

To analyse on which dates trips run and to group similar services we use service patterns. 
Such a pattern simply lists all dates a trip runs on. For example, a trip with a servicepattern 
like c("2019-03-07", "2019-03-14"", "2019-03-21", "2019-03-28") runs every thursday in March 2019. 
To handle these patterns we create an servicepattern_id using a hash function. Ideally there are 
the same number of servicepattern_ids and service_ids. However, in real life feeds this is rarely 
the case. In addition, the usability of service patterns depends largely on the feed and its 
complexity.

```{r}
gtfs_obj <- set_servicepatterns(gtfs_obj)
```

`servicepatterns` is a list containing all date patterns and `trip_servicepatterns` now links 
each trip to a `servicepattern_id`. We can compare the number of unique date patterns to the 
number of service_ids.

```{r eval=FALSE, include=FALSE}
# service ids used
length(unique(gtfs$trips$service_id)) # 70

# unique date patterns 
length(servicepatterns) # 6
```

The feed uses 70 service_ids but there are actually only 6 different date patterns used by 
trips. Other feeds might not have such low numbers, for example the Swiss GTFS feed uses 
around 15'000 service_ids which all identify unique date patterns.

## Analyse Data

### Initial Plot

We'll now try to figure out usable names for those patterns. Grouping and identifying date 
patterns and giving them human readable names is a process that is generally hard to automate. 
A good way to start is visualising the data.

```{r fig.height=4, fig.width=6}
date_servicepattern_table <- inner_join(gtfs$date_service_table, trip_servicepatterns, by = "service_id")

date_servicepattern_table <- date_servicepattern_table %>% left_join(calendar, by = "date")

ggplot(date_servicepattern_table) + theme_bw() + 
  geom_vline(xintercept = seq(min(filter(date_servicepattern_table, weekday == "Sunday")$date), max(date_servicepattern_table$date), 7), color = "#747474") +
  geom_point(aes(x = date, y = servicepattern_id, color = weekday), size = 0.7) + 
  scale_x_date(breaks = scales::date_breaks("1 month")) + theme(legend.position = "bottom")
```

The plot shows that pattern `p_eb8eae871` runs on every sunday from July until October without 
exceptions. `p_99da13743` also runs on sundays but it also covers a monday (September 3rd). 
Similarly, the date pattern `p_831fa75f2` runs every saturday. `p_69c6534e2` covers weekdays 
(mondays through friday), `p_7764f1257` seems to do the same through November with some exceptions. 

### Names for service patterns

It's generally difficult to automatically generate readable names for servicepatterns. Below you 
see a semi automated approach with some heuristics. However, the workflow depends largely on the 
feed and its structure. You might also consider setting names completely manually.

```{r}
suggest_servicepattern_names = function(servicepattern, calendar) {
  servicepattern_calendar = tibble(date = servicepattern) %>% left_join(calendar, by = "date")
  
  # all normal dates without holidays
  calendar_normal = servicepattern_calendar %>% filter(is.na(holiday))
  
  # create a frequency table for all calendar dates without holidays
  weekday_freq = sort(table(calendar_normal$weekday), decreasing = T)
  n_weekdays = length(weekday_freq)
  
  # all holidays that are not covered by normal weekdays anyways
  calendar_holidays <- servicepattern_calendar %>% filter(!is.na(holiday)) %>% filter(!(weekday %in% names(weekday_freq)))

  # Single day service
  if(n_weekdays == 1) {
    wd = names(weekday_freq)[1]
    # while paste0(weekday, "s") is easier, this solution can be used for other languages
    pattern_name = c("Sunday"  = "Sundays", 
        "Monday"    = "Mondays", 
        "Tuesday"   = "Tuesdays", 
        "Wednesday" = "Wednesdays",
        "Thursday"  = "Thursdays",  
        "Friday"    = "Fridays",  
        "Saturday"  = "Saturdays")[wd]
  } 
  # Weekday Service
  else if(n_weekdays == 5 && 
      length(intersect(names(weekday_freq), 
        c("Monday", "Tuesday", "Wednesday", "Thursday", "Friday"))) == 5) {
    pattern_name = "Weekdays"
  }
  # Weekend
  else if(n_weekdays == 2 && 
      length(intersect(names(weekday_freq), c("Saturday", "Sunday"))) == 2) {
    pattern_name = "Weekends"
  }
  # Multiple weekdays that appear regularly
  else if(n_weekdays >= 2 && (max(weekday_freq) - min(weekday_freq)) <= 1) {
    pattern_name = paste(names(weekday_freq), collapse = ", ")
  } 
  # default
  else {
    pattern_name = paste(weekday_freq, names(weekday_freq), sep = "x ", collapse = ", ")
  }
  
  # add holidays
  if(nrow(calendar_holidays) > 0) {
    pattern_name <- paste0(pattern_name, " and ", paste(calendar_holidays$holiday, collapse = ", "))
  }
  
  pattern_name <- paste0(pattern_name, " (", min(servicepattern), " - ", max(servicepattern), ")") 

  return(pattern_name)
}
```

We'll apply this function to our service patterns and create a table with ids and names.

```{r}
servicepattern_names = lapply(servicepatterns, suggest_servicepattern_names, calendar)

servicepatterns_df = tibble(
  servicepattern_id = names(servicepattern_names),
  servicepattern_name = unlist(servicepattern_names, use.names = F)
  )
```

```{r echo=FALSE}
knitr::kable(servicepatterns_df)
```

_work in progress_