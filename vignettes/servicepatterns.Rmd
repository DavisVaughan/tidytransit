---
title: "Service Patterns"
author: "Flavio Poletti"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tidytransit-Service Patterns}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidytransit)
library(dplyr)
library(openssl)
library(ggplot2)
```

## Overview

Each trip in a GTFS feed is referenced to a service_id (in trips.txt). The [GTFS reference](https://developers.google.com/transit/gtfs/reference/#calendartxt) specifies that a "service_id contains an ID that uniquely identifies a set of dates when service is available for one or more routes". A service could run on every weekday or only on saturdays for example. Other possible services run only on holidays during a year, independent of weekdays. However, feeds are not required to indicate anything with service_ids and some feeds even use a unique `service_id` for each trip and day. In this vignette we'll look at a general way to gather information on when trips run by using "service patterns".

## Prepare data

We use a feed from the New York Metropolitan Transportation Authority. It is provided as a sample feed with tidytransit but you can read it directly from the MTA's website. 

```{r}
local_gtfs_path <- system.file("extdata", "google_transit_nyc_subway.zip", package = "tidytransit")
gtfs <- read_gtfs(local_gtfs_path, local=TRUE)
# gtfs <- read_gtfs("http://web.mta.info/developers/data/nyct/subway/google_transit.zip")
```

With `get_date_service_table()` we receive a table that indicates which service_id runs on which date. This is later useful for linking dates and trips via service_id. We'll add weekdays to the dates for further use. You could also join a table with holiday dates, if you have one at hand.

```{r}
gtfs$date_service_table <- get_date_service_table(gtfs)

.weekdays = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")
.weekday_df = data.frame(weekday_nr = 0:6, weekday = .weekdays)

gtfs$date_service_table$weekday_nr <- as.POSIXlt(gtfs$date_service_table$date)$wday
gtfs$date_service_table <- gtfs$date_service_table %>% left_join(.weekday_df, by = "weekday_nr")
gtfs$date_service_table$weekday <- factor(gtfs$date_service_table$weekday, levels = .weekdays)
```

To analyse on which dates trips run and to group similar services we use service patterns. Such a pattern simply lists all dates a trip runs on. For example, a trip with a servicepattern like c("2019-03-07", "2019-03-14"", "2019-03-21", "2019-03-28") runs every thursday in March 2019. To handle these patterns we create an servicepattern_id using a hash function. Ideally there are the same number of servicepattern_ids and service_ids. However, in real life feeds this is rarely the case. In addition, the usability of service patterns depends largely on the feed and its complexity.

```{r}
get_servicepattern = function(dates) {
  paste(sort(dates), collapse = "_")
}

servicepatterns = list()

get_servicepattern_id = function(dates) {
  id = openssl::sha224(get_servicepattern(dates))
  id <- paste0("p_", substr(id, 0, 9))
  
  servicepatterns[[id]] <<- dates
  return(id)
}

trip_servicepatterns <- gtfs$date_service_table %>% 
  inner_join(select(gtfs$trips, service_id, trip_id), by = "service_id") %>% 
  group_by(trip_id, service_id) %>%
	summarise(
		servicepattern_id = get_servicepattern_id(date)
	) %>% ungroup()
```

`servicepatterns` is a list containing all date patterns and `trip_servicepatterns` now links each trip to a `servicepattern_id`. We can compare the number of unique date patterns to the number of service_ids.

```{r eval=FALSE, include=FALSE}
# service ids used
length(unique(gtfs$trips$service_id)) # 70

# unique date patterns 
length(servicepatterns) # 6
```

The feed uses 70 service_ids but there are actually only 6 different date patterns used by trips. Other feeds might not have such low numbers, for example the Swiss GTFS feed uses around 15'000 service_ids which all identify unique date patterns.

## Analyse Data

### Initial Plot

We'll now try to figure out usable names for those patterns. Grouping and identifying date patterns and giving them human readable names is a process that is generally hard to automate. A good way to start is visualising the data.

```{r fig.height=4, fig.width=6}
date_servicepattern_table <- inner_join(gtfs$date_service_table, trip_servicepatterns, by = "service_id")

ggplot(date_servicepattern_table) + theme_bw() + 
  geom_vline(xintercept = seq(min(filter(date_servicepattern_table, weekday == "Sunday")$date), max(date_servicepattern_table$date), 7), color = "#747474") +
  geom_point(aes(x = date, y = servicepattern_id, color = weekday), size = 0.7) + 
  scale_x_date(breaks = scales::date_breaks("1 month")) + theme(legend.position = "bottom")
```

The plot shows that pattern `p_eb8eae871` runs on every sunday from July until October without exceptions. `p_99da13743` also runs on sundays but it also covers a monday (September 3rd). Similarly, the date pattern `p_831fa75f2` runs every saturday. `p_69c6534e2` covers weekdays (mondays through friday), `p_7764f1257` seems to do the same through November with some exceptions. 

### Naming and further use 

You can name those patterns to use them in your analysis. How you name them is up to you, an automated generation of human-readable names has not yet been developed.

```{r}
servicepatterns_df = tribble(~servicepattern_id, ~servicepattern_name,
  "p_eb8eae871", "Sundays",
  "p_99da13743", "Sundays (+ Labor Day)", 
  "p_831fa75f2", "Saturdays",
  "p_7da81d788", "Saturdays", 
  "p_7764f1257", "Weekdays (except holidays)", 
  "p_69c6534e2", "Weekdays"
  )
servicepatterns_df
```

_work in progress_