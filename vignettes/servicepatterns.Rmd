---
title: "Service Patterns"
author: "Flavio Poletti"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tidytransit-Service Patterns}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidytransit)
library(dplyr)
library(lubridate)
library(openssl)
library(ggplot2)
```
  
## Overview

Each trip in a GTFS feed is referenced to a service_id (in trips.txt). The [GTFS reference](https://developers.google.com/transit/gtfs/reference/#calendartxt) 
specifies that a "service_id contains an ID that uniquely identifies a set of dates when 
service is available for one or more routes". A service could run on every weekday or only 
on saturdays for example. Other possible services run only on holidays during a year, 
independent of weekdays. However, feeds are not required to indicate anything with 
service_ids and some feeds even use a unique `service_id` for each trip and day. In 
this vignette we'll look at a general way to gather information on when trips run by 
using "service patterns".
  
## Prepare data

We use a feed from the New York Metropolitan Transportation Authority. It is provided 
as a sample feed with tidytransit but you can read it directly from the MTA's website. 
  
```{r}
local_gtfs_path <- system.file("extdata", "google_transit_nyc_subway.zip", package = "tidytransit")
gtfs <- read_gtfs(local_gtfs_path, local=TRUE)
# gtfs <- read_gtfs("http://web.mta.info/developers/data/nyct/subway/google_transit.zip")
```
  
With `get_date_service_table()` we receive a table that indicates which service_id runs 
on which date. This is later useful for linking dates and trips via service_id. The table 
also shows weekdays. You could also join a table with holiday dates, if you have one at 
hand, we'll use a minimal example with two days.

```{r}
gtfs$date_service_table <- get_date_service_table(gtfs)

holidays = tribble(~date, ~holiday,
  ymd("2018-07-04"), "Independence Day",
  ymd("2018-09-03"), "Labor Day")

calendar = tibble(date = unique(gtfs$date_service_table$date)) %>% 
  mutate(
    weekday = (function(date) {
      c("sunday", "monday", "tuesday", 
        "wednesday", "thursday", "friday", 
        "saturday")[as.POSIXlt(date)$wday + 1]
    })(date)
  )

calendar <- calendar %>% left_join(holidays, by = "date")
```

To analyse on which dates trips run and to group similar services we use service patterns. 
Such a pattern simply lists all dates a trip runs on. For example, a trip with a servicepattern 
like c("2019-03-07", "2019-03-14"", "2019-03-21", "2019-03-28") runs every thursday in March 2019. 
To handle these patterns we create an servicepattern_id using a hash function. Ideally there are 
the same number of servicepattern_ids and service_ids. However, in real life feeds this is rarely 
the case. In addition, the usability of service patterns depends largely on the feed and its 
complexity.

```{r}
get_servicepattern = function(dates) {
  paste(sort(dates), collapse = "_")
}

servicepatterns = list()

get_servicepattern_id = function(dates) {
  id = openssl::sha224(get_servicepattern(dates))
  id <- paste0("p_", substr(id, 0, 9))
  
  servicepatterns[[id]] <<- dates
  return(id)
}

trip_servicepatterns <- gtfs$date_service_table %>% 
  inner_join(select(gtfs$trips, service_id, trip_id), by = "service_id") %>% 
  group_by(trip_id, service_id) %>%
  summarise(
    servicepattern_id = get_servicepattern_id(date)
  ) %>% ungroup()
```

`servicepatterns` is a list containing all date patterns and `trip_servicepatterns` now links 
each trip to a `servicepattern_id`. We can compare the number of unique date patterns to the 
number of service_ids.

```{r eval=FALSE, include=FALSE}
# service ids used
length(unique(gtfs$trips$service_id)) # 70

# unique date patterns 
length(servicepatterns) # 6
```

The feed uses 70 service_ids but there are actually only 6 different date patterns used by 
trips. Other feeds might not have such low numbers, for example the Swiss GTFS feed uses 
around 15'000 service_ids which all identify unique date patterns.

## Analyse Data

### Initial Plot

We'll now try to figure out usable names for those patterns. Grouping and identifying date 
patterns and giving them human readable names is a process that is generally hard to automate. 
A good way to start is visualising the data.

```{r fig.height=4, fig.width=6}
date_servicepattern_table <- inner_join(gtfs$date_service_table, trip_servicepatterns, by = "service_id")

ggplot(date_servicepattern_table) + theme_bw() + 
  geom_vline(xintercept = seq(min(filter(date_servicepattern_table, weekday == "sunday")$date), max(date_servicepattern_table$date), 7), color = "#747474") +
  geom_point(aes(x = date, y = servicepattern_id, color = weekday), size = 0.7) + 
  scale_x_date(breaks = scales::date_breaks("1 month")) + theme(legend.position = "bottom")
```

The plot shows that pattern `p_eb8eae871` runs on every sunday from July until October without 
exceptions. `p_99da13743` also runs on sundays but it also covers a monday (September 3rd). 
Similarly, the date pattern `p_831fa75f2` runs every saturday. `p_69c6534e2` covers weekdays 
(mondays through friday), `p_7764f1257` seems to do the same through November with some exceptions. 

### Names for service patterns

It's generally difficult to automatically generate readable names for servicepatterns. Below you 
see a semi automated approach with some heuristics. However, the workflow depends largely on the 
feed and its structure. You might also consider setting names completely manually.

```{r}
suggest_servicepattern_names = function(servicepattern, calendar) {
  calendar_excerpt = tibble(date = servicepattern) %>% left_join(calendar, by = "date")
  weekday_freq = table(calendar_excerpt$weekday)
  n_weekdays = length(weekday_freq)

  add_date_range = function(string) {
    paste0(string, " (", min(servicepattern), " - ", max(servicepattern), ")") 
  }
  
  weekday_plural = function(weekday) {
  unname(
    c("sunday"  = "Sundays", 
    "monday"    = "Monday", 
    "tuesday"   = "Tuesday", 
    "wednesday" = "Wednesdays",
    "thursday"  = "Thursdays",  
    "friday"    = "Fridays",  
    "saturday"  = "Saturdays")[weekday])
  }
  
  summarise_holidays = function(h) {
    if(any(!is.na(h))) {
      return(paste(h, collapse=", "))
    } else {
      return("")
    }
  }

  # Single day service
  if(n_weekdays == 1) {
    wd = weekday_plural(names(weekday_freq)[1])
    return(add_date_range(wd))
  }

  # Weekday Service
  if(n_weekdays == 5 && length(intersect(names(weekday_freq), c("monday", "tuesday", "wednesday", "thursday", "friday"))) == 5) {
    return(add_date_range("Weekdays"))
  }
  
  # Weekend
  if(n_weekdays == 2 && length(intersect(names(weekday_freq), c("saturday", "sunday"))) == 2) {
    return(add_date_range("Weekends"))
  }
  
  holiday_pattern_summary = calendar_excerpt %>% group_by(weekday) %>% 
    summarise(
      count = dplyr::n(),
      holiday_count = length(holiday[!is.na(holiday)]),
      holiday_names = summarise_holidays(holiday)
    ) %>% arrange(desc(count))
  
  # Multiple weekdays with holidays
  if(sum(holiday_pattern_summary$holiday_count) > 0) {
    weekday_and_holiday_info = weekday_plural(holiday_pattern_summary$weekday[1])
    holiday_names = holiday_pattern_summary$holiday_names[holiday_pattern_summary$holiday_names != ""]
    weekday_and_holiday_info <- paste0(weekday_and_holiday_info, " and ", paste(holiday_names, collapse = ", "))
    return(add_date_range(weekday_and_holiday_info))
  }
  browser()
  # Default case, multiple weekdays without holidays
  pattern_name = paste(weekday_freq, names(weekday_freq), sep = "x ", collapse = ", ")

  return(add_date_range(pattern_name))
}

servicepattern_names = lapply(servicepatterns, suggest_servicepattern_names, calendar)

servicepatterns_df = tibble(
  servicepattern_id = names(servicepattern_names),
  servicepattern_name = unlist(servicepattern_names, use.names = F)
  )

servicepatterns_df
```

_work in progress_