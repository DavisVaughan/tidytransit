---
title: "Generate a departure timetable"
date: "`r Sys.Date()`"
author: Flavio Poletti
output: 
  html_vignette:
    fig_width: 6
    fig_height: 4
vignette: >
  %\VignetteIndexEntry{tidytransit-Timetable}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidytransit)
library(dplyr)
library(openssl)
library(ggplot2)
```

# Overview

In this vignette a departure timetable for a stop is generated. The example is ???

# Preparation

## Read GTFS data

We use a feed from the New York Metropolitan Transportation Authority. It is provided as a sample feed with tidytransit but you can read it directly from the MTA's website. 

```{r}
local_gtfs_path <- system.file("extdata", "google_transit_nyc_subway.zip", package = "tidytransit")
gtfs <- read_gtfs(local_gtfs_path, local=TRUE)
# gtfs <- read_gtfs("http://web.mta.info/developers/data/nyct/subway/google_transit.zip")
```

## trip_origin and trip_headsign

To display where a bus (or any public transit vehicle) is headed on a timetable we need the column `trip_headsign` in `gtfs$trips`. This is an optional field but our example feed provides this information. To display where a vehicle comes from on the timetable we needto create a new column in `gtfs$trips` which we'll call `trip_origin`.

```{r}
# get the id of the first stop in the trip's stop sequence
first_stop_id <- gtfs$stop_times %>% group_by(trip_id) %>% summarise(stop_id = stop_id[which.min(stop_sequence)])

# join with the stops table to get the stop_name
first_stop_names <- left_join(first_stop_id, gtfs$stops, by="stop_id")

# rename the first stop_name as trip_origin
trip_origins <- first_stop_names %>% select(trip_id, trip_origin = stop_name)

# assign the 
gtfs$trips <- left_join(gtfs$trips, trip_origins, by = "trip_id")
```

In case trip_headsign does not exist in the feed it can be generated similarly to trip_origin:

```{r}
if(!exists("trip_headsign", where = gtfs$trips)) {
  # get the first id of the trip's stop sequence
  trip_headsigns <- gtfs$stop_times %>% 
    group_by(trip_id) %>% 
    summarise(stop_id = stop_id[which.max(stop_sequence)]) %>% 
    left_join(gtfs$stops, by="stop_id") %>% select(trip_id, trip_headsign = stop_name)

  # assign to the gtfs object 
  gtfs$trips <- left_join(gtfs$trips, trip_headsigns, by = "trip_id")
}
```

# Build departure timetable

For easier handling of time data we use departure times as `hms::hms()`. Times for the whole feed can be converted with `set_hms_times()`

```{r}
gtfs <- tidytransit::set_hms_times(gtfs)
```


First we need to find the ids of all stops that have the same name which might cover different platforms.

```{r}
stop_ids <- gtfs$stops %>% filter(stop_name == "Knickerbocker Av") %>% select(stop_id)
```

Then we'll fetch all trips departing from these stops. Stop_ids and trips are linked via stop_times. Each trip belongs to a route, the corresponding route info is gathered by joining the trips data frame with `gtfs$routes`.

```{r}
departures <- stop_ids %>% inner_join(gtfs$stop_times %>% select(trip_id, arrival_time_hms, departure_time_hms, stop_id), by = "stop_id")

# add trip info (route_id, service_id, trip_headsign, trip_origin)
departures <- departures %>% left_join(gtfs$trips %>% select(trip_id, route_id, service_id, trip_headsign, trip_origin), by = "trip_id")

# add route info (route_short_name)
departures <- departures %>% left_join(gtfs$routes %>% select(route_id, route_short_name), by = "route_id")
```

We have now gathered all departures that happen on "Knickerbocker Av". However, we do not know on which days the these trips run. Arranging the departures and looking at the head we get an idea how the feed is setup:

```{r}
departures %>% arrange(arrival_time_hms)
```

Looking at the first two departures we see that a train departures at 00:04 and looking at the `service_id` and `trip_id` we can guess that this happens saturdays and weekdays. However, feeds are not required to indicate anything with these ids and some feeds even use a unique `service_id` for each trip and day. We'll look at a general way to gather this information. With `get_date_service_table()` we receive a table that indicates which service id runs on which date.

```{r}
gtfs$date_service_table <- get_date_service_table(gtfs)

weekday_summary = function(x) {
  times_service_runs_on_weekday = table(weekdays(x))
  paste(times_service_runs_on_weekday, names(times_service_runs_on_weekday), sep = "x ", collapse = ", ")
}

service_weekday_summary = gtfs$date_service_table %>% group_by(service_id) %>% summarise(weekday_summary = weekday_summary(date))

print(service_weekday_summary)
```

# date patterns

To analyse on which dates trips run and to group similar services we use `date patterns`. Such a pattern simply lists all dates a trip runs on. For example, a trip with the date_pattern like "2019-03-07_2019-03-14_2019-03-21_2019-03-28" runs on every thursday in March 2019. Naturally, a trip that runs every day during a year has a rather long date pattern string which is why we use a hash function to create a date_pattern_id which makes the data more manageable. Ideally there are the same number of date_pattern_ids and service_ids. However, in real life feeds this is rarely the case. In addition, the usability of `date patterns` depends largely on the feed and its complexity. Note that the following code is not really efficient.

```{r}
get_date_pattern = function(dates) {
  paste(sort(dates), collapse = "_")
}

date_patterns = list()

get_date_pattern_id = function(dates) {
  id = openssl::sha224(get_date_pattern(dates))
  id <- paste0("p_", substr(id, 0, 9))
  
  date_patterns[[id]] <<- dates
  return(id)
}

trip_date_patterns <- gtfs$date_service_table %>% 
  inner_join(select(gtfs$trips, service_id, trip_id), by = "service_id") %>% 
  group_by(trip_id, service_id) %>%
	summarise(
		date_pattern_id = get_date_pattern_id(date)
	) %>% ungroup()
```

`date_patterns` is a list containing all date patterns and `trip_date_patterns` now links each trip to a `date_pattern_id`. We can compare the number of unique date patterns to the number of service_ids.

```{r echo=FALSE}
cat(paste0("service ids used: ", length(unique(gtfs$trips$service_id))), "\n")
cat(paste0("unique date patterns: ", length(date_patterns)))
```

The feed uses 70 service_ids but there are actually only 6 different date patterns used by trips. Other feeds might not have such low numbers, for example the Swiss GTFS feed uses around 15'000 service_ids which all identify unique date patterns.

#### Plotting date pattern

We'll now try to figure out usable names for those patterns. Grouping and identifying date patterns and giving them human readable names is a process that is generally hard to automate. A good way to start is visualising the data.

```{r}
date_pattern_table <- inner_join(gtfs$date_service_table, trip_date_patterns, by = "service_id")

.weekdays = c("Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday")
.weekday_df = data.frame(weekday_nr = 0:6, weekday = .weekdays)

date_pattern_table$weekday_nr <- as.POSIXlt(date_pattern_table$date)$wday
date_pattern_table <- date_pattern_table %>% left_join(.weekday_df, by = "weekday_nr")
date_pattern_table$weekday <- factor(date_pattern_table$weekday, levels = .weekdays)

ggplot(date_pattern_table) + theme_bw() + 
  geom_vline(xintercept = seq(min(filter(date_pattern_table, weekday == "Sunday")$date), max(date_pattern_table$date), 7), color = "#747474") +
  geom_point(aes(x = date, y = date_pattern_id, color = weekday), size = 0.7) + 
  scale_x_date(breaks = scales::date_breaks("1 month")) + theme(legend.position = "bottom")
```

The plot shows that pattern `p_831fa75f2` runs on every saturday from July until October without exceptions. Similarly, the date pattern `p_eb8eae871` runs every sunday. `p_99da13743` also runs on sundays but it also covers a monday (September 3rd). `p_69c6534e2` covers weekdays (mondays through friday), `p_7764f1257` seems to do the same through November with some exceptions. How you name those patterns is up to you.

_work in progress_