=---
title: "Introduction to Transit Service Schedule (GTFS) Mapping"
author: "Tom Buckley"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{tidytransit-headways}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dplyr)
library(tidytransit)
library(ggplot2)
library(sf)
```

# Introduction

The focus of this vignette is on how to use R to make graphics for where and how often transit service operates basedon schedule data published in the [General Transit Feed Specification](http://gtfs.org/). 

We're going to review how to use this package to:

1) Estimate headways at transit stops along 1 line
2) Estimate headways along 1 transit line
3) Map headways at multiple stops 
4) Map headways along multiple lines 
5) Estimate and map total departures along all routes and lines in the NYC Subway.

# Importing the NYC MTA Subway Schedule

We'll start by importing a snapshot of the NYC MTA's subway schedule, which is included with the package. 

```{r}
local_gtfs_path <- system.file("extdata", "google_transit_nyc_subway.zip", package = "tidytransit")
gtfs <- read_gtfs(local_gtfs_path, local=TRUE)
# gtfs <- read_gtfs("http://web.mta.info/developers/data/nyct/subway/google_transit.zip")
```

# Summarizing Frequency of Service 

## Service Selection

GTFS feeds typically contain a schedule of all the schedules of service for a given system. Selecting a schedule of service in NYC allows us to focus on, for example, non-holiday weekday service, in the Fall of 2019. In some feeds, service selection can be more or less complicated than NYC. In any case, you'll want to read the [service patterns](http://tidytransit.r-transit.org/articles/servicepatterns.html) vignette included in this package in order to see how you can select the right service for your needs. 

We use one of the functions described in that vignette to create a table on the gtfs feed that lets us filter by weekday/weekend service. 

```{r}
gtfs <- set_servicepattern(gtfs)
```

We use the graphic on weekday/weekend service from that vignette in order to select a set of service_id's from the table, which we can pass to the frequency and headway summary functions. 

![Weekday Service](http://tidytransit.r-transit.org/articles/servicepatterns_files/figure-html/unnamed-chunk-7-1.png "Weekday Service")

```{r}
service_ids <- gtfs$.$service_pattern %>% 
  filter(servicepattern_id == 's_e25d6ca') %>% 
  pull(service_id)
head(service_ids)
```

So, what are these magic service_id codes? How they are put together varies from operator to operator. The important thing is that the service_id's are also a field on the `trips` table, which describes all the trips taken in the system. 

Lets see how many trips fall under each of these service_id's on the trips table, and how they relate to routes. 

```{r}
gtfs$trips %>%
  filter(service_id %in% service_ids) %>%
  group_by(service_id, route_id) %>%
  summarise(count = n())
```

It looks like the NYC Subway GTFS is identifying service_id's, at least partially, by the route that a trip runs on. This means that we probably can't just use 1 service_id in order to understand weekday schedules across the entire NYC Subway system using GTFS. Some GTFS feeds are simpler: a single service_id might relate to 'all weekday services'. In any case, we can pass the entire set of service_id's to the frequency functions included in the package. 

## Headways Between 6 am and 10 am on stops on the 1 Train. 

So, now that we've identified a set of service_id's, we can summarize service between 6 am and 10 pm for the NYC Subway system on weekdays.  

```{r}
am_freq <- get_stop_frequency(gtfs, start_hour = 6, end_hour = 10)
```

```{r}
head(am_freq)
```

This table includes columns for the id for a given stop, the route_id, our selected service_id's, and the number of departures and the average headway for a given direction for the itme we specified. For that time window, the `get_stop_frequency` function simply counts the number of departures within the time frame that we specified (6 am to 10 am). Then, to get headways, it just divides the number of departures by the number of minutes by the number of departures, and rounds to the nearest integer. 

Lets have a look at distribution of calculated headways for the ![1 Train](http://web.mta.info/nyct/service/images/oneline.gif "1 Train"), which runs from the Bronx down to the Bottom of Manhattan. 

First, we filter the `am_freq` data frame to just stops going in 1 direction on the 1 train, and then we join to the `stops` table, which includes a more descriptive stop_name, by using the stop_id. 

```{r}
one_line_stops <- am_freq %>% 
    filter(route_id==1 & direction_id==0) %>%
    left_join(gtfs$stops, by ="stop_id")
```

As we can see, some stops seem to have higher headways than others, even when the train is running in the same direction. This may be counterintuitive, because we might expect the train to run through every stop the same amount of times for a given direction. 

Lets inspect the stops at which headways are higher. 

```{r}
one_line_stops %>% 
  arrange(desc(headway)) %>% 
  select(stop_name, departures, headway) %>% 
  head()
```

And those at which headways are lower:

```{r}
one_line_stops %>% 
  arrange(desc(headway)) %>% 
  select(stop_name, departures, headway) %>% 
  tail()
```

Here we can see that the 242-Van Cortland Stop, the last stop up North, in the Bronx, has noticeably higher headways (8 mins) at this time of day than the South Ferry Stop, which is at the south end of Manhattan.

Lets also plot the headways at these stops on a map to see how they are distributed across the city. 

First, we'll use the `get_stop_geometry` function, which converts the latitudes and longitudes on the stops table in the GTFS feed into  [simple features](https://r-spatial.github.io/sf/articles/sf1.html).  

```{r}
nyc_stops_sf <- get_stop_geometry(gtfs$stops)
```

Now we can join those stop coordinates to the 1 line's calculated stop headways. 

```{r}
one_line_stops_sf <- nyc_stops_sf %>%
  right_join(one_line_stops, by="stop_id") 
```

And then use ggplot's `geom_sf` to plot the headways. 

```{r}
one_line_stops_sf %>% 
  ggplot() + 
  geom_sf(aes(color=headway)) +
  theme_bw()
```

On the map too, we can see that there is some variation in stop headways. During certain times of the day, the 1 train skips stops north of a certain stop in manhattan, presumably in order to turn around and provide shorter headways to stops south of that stop.

Finally, we can easily summarise what the headways are like along the entire route now, by using r's default summary function for the vector of headways. 

```{r}
summary(one_line_stops$headway)
```

This is the same method that tidytransit uses to summarise headways along all routes in the system when we use the `get_route_frequency` function, which we'll try next.  

## Headways Between 6 am and 10 am on stops for all Routes

Now we'll use the `get_route_frequency` function to summarise transit service by route, for the same time period. 

```{r}
am_route_freq <- get_route_frequency(gtfs, service_ids = service_ids, start_hour = 6, end_hour = 10) 
head(am_route_freq)
```

Since, under the hood, this table is a summary of stop frequencies along each route, it includes the same variables as a summary of the headways at each stop along the route, as well as a sum of all departures. Again, its important to note that this summary is based on the trips that happened within the time frame we specify. 
As with the stops, we can easily join this table to simple features and then plot it on a map. Note that here too we pass in the select service_id's from above, as the route run by a vehicle also depends on the selected service. 

```{r}
routes_sf <- get_route_geometry(gtfs, service_ids = service_ids)
```

Then we join the geometries to the calculated frequencies:

```{r}
routes_sf <- routes_sf %>% 
  right_join(am_route_freq, by = 'route_id')
```

And finally, lets plot the routes with median headways of less than 6 minutes in the morning.

```{r, warn=FALSE}
routes_sf %>% 
  filter(median_headways<6) %>%
  ggplot() + 
  geom_sf(aes(colour=as.factor(median_headways))) + 
  labs(color = "Headways") +
  geom_sf_text(aes(label=route_id)) +
  theme_bw() 
```

And now lets look at the routes having headways greater than 5 minutes and less than 9. 

```{r, warn=FALSE}
routes_sf %>% 
  filter(median_headways>5 & median_headways<9) %>%
  ggplot() + 
  geom_sf(aes(colour=as.factor(median_headways))) + 
  labs(color = "Headways") +
  geom_sf_text(aes(label=route_id)) +
  theme_bw() 
```

Its clear that a number of the route lines overlap, so representing how transit riders might experience headways on a plot will require something more complex. 

Lets take a look at the map without any frequency to get a better sense of how lines overlap in themselves. 

```{r}
routes_sf %>% 
  ggplot() + 
  geom_sf(color=alpha("red",0.2)) +
  theme_bw() 
```

## Departures Between 6 am and 10 am for all Stops and for All Routes

Still, we'd like to represent where and how frequently the subway runs in NYC in the morning. How can we do so?

One answer might be change units. So far, we've summarized frequency by stop, and now by route. And now that we see how routes overlap, we might want to consider using a different unit. The GTFS data standard comes with a `shapes` table, which, if modeled correctly, should allow us to say what the frequency of vehicles passing through any given shape is, using similar methods. This kind of method is beyond the scope of this vignette. 

Alternatively, regular ggplot users might expect the ggplot `dodge` function to allow us to move around these lines but, by design, thats not possible with `geom_sf`. 

So we'll use a cartographic trick, scaling each line according to total departures and close to a number around .001 [decimal degrees](https://en.wikipedia.org/wiki/Decimal_degrees) which is a about the length of a street, which will fit on the map well. One might call this a cartogram. 

```{r}
routes_sf_buffer <- st_buffer(routes_sf,
                              dist=routes_sf$total_departures/1e6)
```

Next, when we render the map, we'll make sure to make the borders around each route transparent, and set the opacity for the fill of all the polygons high again. 

```{r}
routes_sf_buffer %>% 
  ggplot() + 
  geom_sf(colour=alpha("white",0),fill=alpha("red",0.2)) +
  theme_bw() 
```

Now we have a rough representation of the question we set out to answer: where and how frequently does transit service run in the AM in the NYC Subway. Note that in this graphic, the intensity of the red tells you how many overlapping trains run through the line and the thickness of the lines represents how many run along each line. 

We can combine this with stops to get a sense of how central stops relate to routes. 

```{r}
nyc_stop_am_departures_main <- nyc_stops_sf %>% left_join(am_freq) %>% 
  filter(departures>50)
```

First, we'll leverage the common `stop_name` variable to group and count departures, in both directions, for all stops, filtering to out a number of smaller stops for more graphical clarity. 

```{r}
nyc_stops <- left_join(gtfs$stops,am_freq, by="stop_id")

stop_departures <- nyc_stops %>%  
  group_by(stop_name) %>%
  transmute(total_departures=sum(departures, na.rm=TRUE))

nyc_stops1 <- right_join(nyc_stops_sf,
                        stop_departures, by="stop_name")

stop_departures <- nyc_stops1 %>%
  filter(total_departures>250)
```

Finally, we can plot both the route line counts and the stop departure counts on one map:

```{r}
ggplot() + 
  geom_sf(data=routes_sf_buffer,colour=alpha("white",0),fill=alpha("red",0.3)) +
  geom_sf(data=stop_departures, aes(size=total_departures), shape=0) + 
  labs(size = "Departures (Hundreds)") +
  theme_bw() +
  theme(legend.position="none")
```

Its easy to see how people could spend a lot of time designing better maps for the NYC Subway System

![Subway](https://upload.wikimedia.org/wikipedia/commons/0/04/NYC_subway-4D.svg "NYC Subway")
